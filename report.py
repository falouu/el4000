#!/usr/bin/env python

from argparse import ArgumentParser
from datetime import datetime
from io import TextIOWrapper
import logging
import os

from el4000 import ALL_DATA_RAW_FILENAME

_logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

SIMPLE_STATS_OUTPUT_FILENAME = "simple-stats.yml"

EXPECTED_DATA_FIELDS = ["date", "voltage", "current", "power_factor", "apparent_power", "effective_power"]

expected_header_line = ",".join(EXPECTED_DATA_FIELDS) + "\n"
i_date = EXPECTED_DATA_FIELDS.index("date")
i_voltage = EXPECTED_DATA_FIELDS.index("voltage")
i_current = EXPECTED_DATA_FIELDS.index("current")
i_power_factor = EXPECTED_DATA_FIELDS.index("power_factor")
i_apparent_power = EXPECTED_DATA_FIELDS.index("apparent_power")
i_effective_power = EXPECTED_DATA_FIELDS.index("effective_power")


def read_data(data_file_path: str):
    with open(data_file_path) as file:
        header = file.readline()
        if not header == expected_header_line:
            raise Exception("Invalid header in data file: " + header)

        records = []
        for line in file:
            fields = line.strip().split(",")
            if len(fields) != 6:
                raise Exception("Invalid number of fields in data: " + len(fields))

            record = [None] * len(EXPECTED_DATA_FIELDS)
            
            record[i_date] = datetime.strptime(fields[i_date], '%Y-%m-%d %H:%M')
            record[i_voltage] = float(fields[i_voltage])
            record[i_current] = float(fields[i_current])
            record[i_power_factor] = float(fields[i_power_factor])
            record[i_apparent_power] = float(fields[i_apparent_power])
            record[i_effective_power] = float(fields[i_effective_power])
            
            records.append(record)

        return records

def _get_max(records, field_index):
    if len(records) == 0:
        return None
    max_val = records[0][field_index]
    for record in records:
        if record[field_index] > max_val:
            max_val = record[field_index]
    return max_val

def _get_min(records, field_index):
    if len(records) == 0:
        return None
    max_val = records[0][field_index]
    for record in records:
        if record[field_index] < max_val:
            max_val = record[field_index]
    return max_val

def get_max_voltage(records):
    return _get_max(records, i_voltage)

def get_min_voltage(records):
    return _get_min(records, i_voltage)

def get_max_effective_power(records):
    return _get_max(records, i_effective_power)


def write_simple_stats_file(all_data, dir):
    with open(os.path.join(dir, SIMPLE_STATS_OUTPUT_FILENAME), 'x') as file:
        file.write("max effective power [W]: {}\n".format(get_max_effective_power(all_data)))
        file.write("min voltage [V]: {}\n".format(get_min_voltage(all_data)))
        file.write("max voltage [V]: {}\n".format(get_max_voltage(all_data)))
    _logger.info("{} file written".format(SIMPLE_STATS_OUTPUT_FILENAME))


parser = ArgumentParser(description='Energy Logger 4000 report from data. \
    Run only after running el4000.py --dir <directory>.')

parser.add_argument('dir', metavar='data_dir',
                    help='directory with data. It searches for files generated by el4000.py --dir <data_dir>')

if __name__ == '__main__':
    args = parser.parse_args()

    if not os.path.isdir(args.dir):
        raise Exception("Directory '{}' does not exist")

    all_data_filepath = os.path.join(args.dir, ALL_DATA_RAW_FILENAME)
    all_data = read_data(all_data_filepath)
    _logger.info("Read all data: {} entries".format(len(all_data)))
    write_simple_stats_file(all_data, args.dir)
    
        